## 项目当前架构分析

根据代码分析，你的 peptide_opt 项目当前架构如下：

| 组件 | 现状 |
|-----|------|
| **任务处理器** | `AsyncTaskProcessor` 使用 `ThreadPoolExecutor(max_workers=1)` 单任务模式 |
| **数据库轮询** | 每次获取 1 个 pending 任务，使用行级锁 |
| **存储** | SeaweedFS 对象存储 |
| **容器部署** | 多容器 Worker 模式（支持 `--scale`）|

**已实现 方案二（多容器 Worker 模式）**

---

## 多用户并发方案对比

### 方案一：扩展单容器内部并发能力 ⭐ 最简单

**适用场景：** 任务量中等，硬件资源足够

```
┌─────────────────────────────────────────┐
│           peptide-opt 容器               │
│  ┌─────────────────────────────────┐    │
│  │     AsyncTaskProcessor          │    │
│  │  ┌───────────────────────────┐  │    │
│  │  │ ThreadPoolExecutor        │  │    │
│  │  │  Worker 1 ─── Task A      │  │    │
│  │  │  Worker 2 ─── Task B      │  │    │
│  │  │  Worker 3 ─── Task C      │  │    │
│  │  │  ...                      │  │    │
│  │  │  Worker N ─── Task N      │  │    │
│  │  └───────────────────────────┘  │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**改动点：**
1. 增加 `max_workers` 配置（可通过环境变量控制）
2. 添加资源限制（防止 OOM）
3. 添加任务队列管理

**优点：** 改动最小，部署简单
**缺点：** 扩展性有限，无法水平扩展

---

### 方案二：多容器 Worker 模式（水平扩展）⭐⭐ 推荐

**适用场景：** 高并发，需要弹性扩缩容

```
                     ┌─────────────┐
                     │  PostgreSQL │
                     │  (任务队列)  │
                     └──────┬──────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ peptide-opt-1 │   │ peptide-opt-2 │   │ peptide-opt-3 │
│   (Worker)    │   │   (Worker)    │   │   (Worker)    │
└───────────────┘   └───────────────┘   └───────────────┘
```

**改动点：**
1. 移除 `container_name` 允许多实例
2. 使用 `docker compose up --scale peptide-opt=3`
3. 添加数据库行级锁防止重复处理
4. 添加负载均衡（可选，用于 API）

**优点：** 水平扩展，高可用
**缺点：** 需要处理任务竞争问题

---

### 方案三：Celery + Redis 任务队列 ⭐⭐⭐ 最专业

**适用场景：** 企业级部署，复杂任务调度

```
┌──────────┐      ┌──────────┐      ┌──────────────────────────┐
│ AstraMol │──────│  Redis   │──────│     Celery Workers       │
│  (API)   │      │ (Broker) │      │  ┌────────┐ ┌────────┐  │
└──────────┘      └──────────┘      │  │Worker 1│ │Worker 2│  │
                                    │  └────────┘ └────────┘  │
                                    │  ┌────────┐ ┌────────┐  │
                                    │  │Worker 3│ │Worker N│  │
                                    │  └────────┘ └────────┘  │
                                    └──────────────────────────┘
                                              │
                                              ▼
                                    ┌──────────────────┐
                                    │ Flower (监控面板) │
                                    └──────────────────┘
```

**改动点：**
1. 添加 Redis 作为消息队列
2. 将任务逻辑改为 Celery Task
3. 添加 Flower 监控面板
4. 分离 API 服务和 Worker 服务

**优点：** 功能最完整，支持重试、定时任务、监控
**缺点：** 改动较大，引入新组件

---

### 方案四：Kubernetes + HPA 自动扩缩容

**适用场景：** 云原生部署，自动弹性伸缩

```
┌─────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                    │
│  ┌─────────────────────────────────────────────────┐    │
│  │              peptide-opt Deployment              │    │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐           │    │
│  │  │  Pod 1  │ │  Pod 2  │ │  Pod N  │  ← HPA    │    │
│  │  └─────────┘ └─────────┘ └─────────┘           │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │  PostgreSQL │  │  SeaweedFS  │  │ Prometheus  │     │
│  │  (StatefulSet)│ │ (StatefulSet)│ │ (监控)      │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────────────────────┘
```

**优点：** 自动扩缩容，云原生
**缺点：** 需要 K8s 集群，学习成本高

---

## 方案推荐

| 方案 | 复杂度 | 改动量 | 扩展性 | 推荐场景 |
|-----|-------|-------|-------|---------|
| **方案一** | ⭐ | 小 | 有限 | 快速上线，用户量少 |
| **方案二** | ⭐⭐ | 中 | 好 | **✅ 已实现** |
| **方案三** | ⭐⭐⭐ | 大 | 优秀 | 长期规划 |
| **方案四** | ⭐⭐⭐⭐ | 很大 | 最优 | 云原生部署 |

---

## ✅ 方案二实施完成

### 已完成的改动

#### 1. docker-compose.yml 修改
- 移除 `container_name` 固定命名，支持多实例
- 移除固定端口映射（Worker 模式不需要对外暴露端口）
- 支持 `--scale` 参数水平扩展

#### 2. 任务处理器 (processor.py) 修改
- 使用 `SELECT FOR UPDATE SKIP LOCKED` 实现数据库行级锁
- 每个 Worker 实例每次只获取并处理一个任务
- 添加唯一 worker_id 用于日志追踪
- 获取任务后立即更新状态为 `processing`

#### 3. 部署脚本 (docker-manage.sh) 修改
- 添加 `--workers N` 参数指定启动实例数
- 添加 `scale N` 命令动态扩缩容
- 更新帮助信息

### 使用方法

```bash
# 进入项目目录
cd /home/songyou/projects/peptide_opt

# 构建镜像
./scripts/docker-manage.sh build

# 启动 3 个 Worker 实例
./scripts/docker-manage.sh start --workers 3

# 或使用 docker compose 直接启动
cd docker && docker compose up -d --scale peptide-opt=3

# 查看运行状态
./scripts/docker-manage.sh status

# 动态扩容到 5 个实例
./scripts/docker-manage.sh scale 5

# 缩容到 2 个实例
./scripts/docker-manage.sh scale 2

# 查看所有 Worker 日志
./scripts/docker-manage.sh logs -f

# 停止所有实例
./scripts/docker-manage.sh stop
```

### 工作原理

```
                     ┌─────────────┐
                     │  PostgreSQL │
                     │  (任务队列)  │
                     └──────┬──────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ peptide-opt-1 │   │ peptide-opt-2 │   │ peptide-opt-3 │
│  worker_id=a1 │   │  worker_id=b2 │   │  worker_id=c3 │
│               │   │               │   │               │
│ SELECT...     │   │ SELECT...     │   │ SELECT...     │
│ FOR UPDATE    │   │ FOR UPDATE    │   │ FOR UPDATE    │
│ SKIP LOCKED   │   │ SKIP LOCKED   │   │ SKIP LOCKED   │
└───────────────┘   └───────────────┘   └───────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
   处理任务 A          处理任务 B          处理任务 C
```

**关键机制：**
1. 每个 Worker 轮询数据库获取 `pending` 状态的任务
2. 使用 `FOR UPDATE SKIP LOCKED` 确保同一任务不会被多个 Worker 同时获取
3. 获取任务后立即更新状态为 `processing`
4. 任务完成后更新状态为 `finished` 或 `failed`

### 注意事项

1. **资源规划**：每个 Worker 实例会占用一定的内存和 CPU，根据服务器配置决定实例数量
2. **数据库连接**：多实例会增加数据库连接数，注意数据库连接池配置
3. **日志管理**：每个实例有独立的 worker_id，便于排查问题 